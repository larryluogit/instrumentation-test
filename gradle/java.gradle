import java.time.Duration

apply plugin: 'java'
apply plugin: 'groovy'

apply from: "$rootDir/gradle/spotless.gradle"
apply from: "$rootDir/gradle/checkstyle.gradle"
apply from: "$rootDir/gradle/codenarc.gradle"
apply from: "$rootDir/gradle/spotbugs.gradle"

def applyCodeCoverage = !(
  project.path.startsWith(":smoke-tests") ||
    //TODO why some tests fail on java 11 if jacoco is present?
    project.path == ":opentelemetry-auto" ||
    project.path == ":load-generator" ||
    project.path.startsWith(":benchmark") ||
    project.path.startsWith(":instrumentation"))

if (applyCodeCoverage) {
  apply from: "$rootDir/gradle/jacoco.gradle"
}

sourceCompatibility = 1.7
targetCompatibility = 1.7

if (project.hasProperty('minJavaVersionForTests') && project.getProperty('minJavaVersionForTests') != JavaVersion.VERSION_1_7) {
  def version = JavaVersion.toVersion(project.getProperty('minJavaVersionForTests'))
  def name = "java$version.majorVersion"
  sourceSets {
    "main_$name" {
      java.srcDirs "${project.projectDir}/src/main/$name"
    }
  }

  "compileMain_${name}Java" {
    sourceCompatibility = version
    targetCompatibility = version
  }

  // Note: ideally lombok plugin would do this for us, but currently it doesn't support custom
  // source sets. See https://github.com/franzbecker/gradle-lombok/issues/17.
  dependencies {
    compileOnly sourceSets."main_$name".compileClasspath
    compile sourceSets."main_$name".output

    "main_${name}CompileOnly" "org.projectlombok:lombok:${project.lombok.version}" transitive false
    "main_${name}AnnotationProcessor" "org.projectlombok:lombok:${project.lombok.version}" transitive false
  }

  jar {
    from sourceSets."main_$name".output
  }

  // In some cases we would like to avoid setting java version to `minJavaVersionForTests`.
  // For example we would like to be able to run profiling tests with ZULU8, but we cannot run it with other JDK8 implementations at the moment
  def skipSettingTestJavaVersion = project.hasProperty('skipSettingTestJavaVersion') && project.getProperty('skipSettingTestJavaVersion')
  if (!skipSettingTestJavaVersion) {
    tasks.withType(JavaCompile).configureEach {
      if (it.name.toLowerCase().contains("test")) {
        sourceCompatibility = version
        targetCompatibility = version
      }
    }
  }
}

java {
  // See https://docs.gradle.org/current/userguide/upgrading_version_5.html, Automatic target JVM version
  disableAutoTargetJvm()
}

[JavaCompile, ScalaCompile].each { type ->
  tasks.withType(type) {
    doFirst {
      // We do this specifically for Java7 bytecode generation because we would like to be able to compile
      // with Java8+ compiler. This likely would require some modifications when we switch to java11 compiler.
      // Using proper Java7 bootstrap and extensions allows to be sure our code will run on real Java7.
      if (JavaVersion.toVersion(sourceCompatibility) == JavaVersion.VERSION_1_7
        && JavaVersion.current() != JavaVersion.VERSION_1_7
        && System.env.JAVA_7_HOME != null) {
        options.fork = true
        options.bootstrapClasspath = fileTree(include: ['*.jar'], dir: "${System.env.JAVA_7_HOME}/jre/lib/")
        options.extensionDirs = "${System.env.JAVA_7_HOME}/jre/lib/ext/"
      }
    }
  }
}

apply plugin: "io.franzbecker.gradle-lombok"

lombok { // optional: values below are the defaults
  version = versions.lombok
  sha256 = ""
}

apply plugin: "eclipse"
eclipse {
  classpath {
    downloadSources = true
    downloadJavadoc = true
  }
}
if (configurations.find { it.name == 'jmh' }) {
  eclipse.classpath.plusConfigurations += [configurations.jmh]
}

jar {
  /*
  Make Jar build fail on duplicate files

  By default Gradle Jar task can put multiple files with the same name
  into a Jar. This may lead to confusion. For example if auto-service
  annotation processing creates files with same name in `scala` and
  `java` directory this would result in Jar having two files with the
  same name in it. Which in turn would result in only one of those
  files being actually considered when that Jar is used leading to very
  confusing failures.

  Instead we should 'fail early' and avoid building such Jars.
  */
  duplicatesStrategy = 'fail'
}

tasks.register("packageSources", Jar) {
  classifier = 'sources'
  from sourceSets.main.allSource
}
artifacts.archives packageSources

repositories {
  jcenter()
  mavenCentral()
  maven {
    url "https://adoptopenjdk.jfrog.io/adoptopenjdk/jmc-libs-snapshots"
  }
  maven {
    url "https://repo.typesafe.com/typesafe/releases"
  }
  // this is only needed for the working against unreleased otel-java snapshots
  maven {
    url "https://oss.jfrog.org/artifactory/oss-snapshot-local"
    content {
      includeGroup "io.opentelemetry"
    }
  }
  mavenLocal()
}

dependencies {
  testCompile deps.spock
  testCompile deps.groovy
  testCompile deps.testLogging
  testCompile group: 'info.solidsoft.spock', name: 'spock-global-unroll', version: '0.5.1'
  testCompile group: 'com.anotherchrisberry', name: 'spock-retry', version: '0.6.4'
  testCompile group: 'com.github.stefanbirkner', name: 'system-rules', version: '1.19.0'
}

jar {
  manifest {
    attributes(
      "Implementation-Title": project.name,
      "Implementation-Version": project.version,
      "Implementation-Vendor": "OpenTelemetry",
      "Implementation-URL": "https://github.com/open-telemetry/opentelemetry-auto-instr-java",
    )
  }
}

tasks.withType(Javadoc).configureEach {
  options.encoding = "utf-8"
  options.docEncoding = "utf-8"
  options.charSet = "utf-8"

  options.addStringOption('Xdoclint:none', '-quiet')

  doFirst {
    if (project.ext.has("apiLinks")) {
      options.links(*project.apiLinks)
    }
  }
}

javadoc {
  source = sourceSets.main.allJava
  classpath = configurations.compileClasspath

  options {
    setMemberLevel JavadocMemberLevel.PUBLIC
    setAuthor true

    links "https://docs.oracle.com/javase/8/docs/api/"
    source = 8
  }
}

tasks.register("sourceJar", Jar) {
  from sourceSets.main.allJava
  classifier = 'sources'
}

tasks.register("javaDocJar", Jar) {
  from javadoc.destinationDir
  classifier = 'javadoc'
  dependsOn javadoc
}

artifacts {
  archives sourceJar
  archives javaDocJar
}

project.afterEvaluate {
  if (project.plugins.hasPlugin('org.unbroken-dome.test-sets') && configurations.hasProperty("latestDepTestRuntime")) {
    tasks.withType(Test).configureEach {
      doFirst {
        def testArtifacts = configurations.testRuntime.resolvedConfiguration.resolvedArtifacts
        def latestTestArtifacts = configurations.latestDepTestRuntime.resolvedConfiguration.resolvedArtifacts
        assert testArtifacts != latestTestArtifacts: "latestDepTest dependencies are identical to test"
      }
    }
  }
}

if (project.plugins.hasPlugin('com.github.johnrengelman.shadow')) {
  // Remove the no-deps jar from the archives to prevent publication
  configurations.archives.with {
    artifacts.remove artifacts.find {
      if (it.hasProperty("delegate")) {
        it.delegate.archiveTask.is jar
      } else {
        it.archiveTask.is jar
      }
    }
  }
  artifacts {
    archives shadowJar
  }
}

if (project.hasProperty("removeJarVersionNumbers") && removeJarVersionNumbers) {
  tasks.withType(AbstractArchiveTask).configureEach {
    version = null
  }
}


if (!rootProject.ext.has("javaExecutableVersionCache")) {
  rootProject.ext.javaExecutableVersionCache = [:]
}

/**
 * Returns version of java from a given java home.
 */
JavaVersion getJavaHomeVersion(String javaHome) {
  def cache = rootProject.ext.javaExecutableVersionCache
  if (cache.containsKey(javaHome)) {
    return cache.get(javaHome)
  }
  new ByteArrayOutputStream().withStream { stream ->
    exec {
      commandLine = [toExecutable(javaHome), "-version"]
      errorOutput = stream
    }
    def output = stream.toString()
    for (def line : output.split('\n')) {
      line = line.trim()
      def matcher = line =~ /^(?:java|openjdk) version "([^"]+)"/
      if (matcher) {
        def version = JavaVersion.toVersion(matcher.group(1))
        cache.put(javaHome, version)
        return version
      }
    }

    // Getting here means we didn't find a line matching the version pattern.
    throw new GradleScriptException("Cannot determine java version. Executable: ${javaHome}, output: ${output}", null)
  }
}

def isJavaVersionAllowed(JavaVersion version) {
  if (project.hasProperty('minJavaVersionForTests') && project.getProperty('minJavaVersionForTests').compareTo(version) > 0) {
    return false
  }
  if (project.hasProperty('maxJavaVersionForTests') && project.getProperty('maxJavaVersionForTests').compareTo(version) < 0) {
    return false
  }
  return true
}

/**
 * For a given java home return the location of java executable
 */
static String toExecutable(String javaHome) {
  return Objects.requireNonNull(javaHome) + "/bin/java"
}

/**
 * Returns java home for a given version or {@code null} if not found
 */
String findJavaHome(JavaVersion version) {
  def javaHome = System.getenv("JAVA_${version.majorVersion}_HOME")
  if (javaHome == null) {
    return null
  }
  def foundVersion = getJavaHomeVersion(javaHome)
  return version == foundVersion ? javaHome : null
}

ext {
  findJavaHome = this.&findJavaHome
}

def addTestRule(String testTaskName) {
  def prefix = testTaskName + "Java"
  tasks.addRule("Pattern: $prefix<Version>: Runs tests using given java version") { String taskName ->
    if (taskName.startsWith(prefix)) {
      def requestedJavaVersion = JavaVersion.toVersion(taskName - prefix)
      def gradleJavaVersion = JavaVersion.current()

      if (gradleJavaVersion != requestedJavaVersion) {
        def javaHomeForTests = findJavaHome(requestedJavaVersion)
        if (javaHomeForTests != null) {

          tasks.withType(Test).all {
            // minJavaVersionForTests property, which specifies java version requirements for tests,
            // currently does not work with custom source sets created by org.unbroken-dome.test-sets plugin.
            // Thus we are forced to ignore all of them
            // TODO solve this problem. We want to run custom test sets with all java versions as well
            if (name != testTaskName) {
              return
            }
            executable = toExecutable(javaHomeForTests)
            enabled = isJavaVersionAllowed(requestedJavaVersion)
            if (requestedJavaVersion.isJava7()) {
              // Disable JIT for this method. Sometimes Java7 JVM crashes trying to compile it.
              jvmArgs '-XX:CompileCommand=exclude,net.bytebuddy.description.type.TypeDescription$Generic$Visitor$Substitutor::onParameterizedType'
            }
          }
        } else {
          throw new BuildCancelledException("Requested java version $requestedJavaVersion not found")
        }
      }

      task(taskName, dependsOn: testTaskName)
    }
  }
}

addTestRule("test")
addTestRule("latestDepTest")

tasks.withType(Test).configureEach {
  if (project.findProperty("enableJunitPlatform") == true) {
    useJUnitPlatform()
  }

  // All tests must complete within 15 minutes.
  // This value is quite big because with lower values (3 mins) we were experiencing large number of false positives
  timeout = Duration.ofMinutes(15)

  // Disable all tests if current JVM doesn't match version requirements
  // Disable all tests if skipTests property was specified
  enabled = isJavaVersionAllowed(JavaVersion.current()) && !project.rootProject.hasProperty("skipTests")
}

plugins.withType(BasePlugin) {
  project.afterEvaluate {
    def deleteTasks = tasks.withType(Delete) + project.tasks.findByPath('clean')
    def otherTasks = tasks - deleteTasks
    otherTasks*.mustRunAfter deleteTasks
  }
}
