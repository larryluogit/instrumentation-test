package io.opentelemetry.auto.decorator;

import io.opentelemetry.OpenTelemetry;
import io.opentelemetry.auto.api.MoreTags;
import io.opentelemetry.auto.instrumentation.api.AgentScope;
import io.opentelemetry.auto.instrumentation.api.AgentSpan;
import io.opentelemetry.auto.instrumentation.api.SpanScopePair;
import io.opentelemetry.auto.instrumentation.api.Tags;
import io.opentelemetry.context.Scope;
import io.opentelemetry.context.propagation.HttpTextFormat;
import io.opentelemetry.trace.Span;
import io.opentelemetry.trace.SpanContext;
import io.opentelemetry.trace.Status;
import io.opentelemetry.trace.Tracer;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.concurrent.ExecutionException;

public abstract class BaseDecorator {

  private final Tracer tracer;

  protected BaseDecorator() {
    tracer = OpenTelemetry.getTracerFactory().get(getTracerName());
  }

  /**
   * Returns the default span type generated by this Decorator
   *
   * @return
   */
  protected abstract String getSpanType();

  /**
   * Returns the component name of this Decorator. This method should be overridden by all
   * Decorators to return a component name uniquely identifying this instrumentation module.
   *
   * @return
   */
  protected abstract String getComponentName();

  /**
   * Returns the tracer name associated with this Decorator.
   *
   * @return
   */
  protected String getTracerName() {
    return "io.opentelemetry.auto." + getComponentName();
  }

  /**
   * Returns the {@link Tracer} instance associated with this Decorator.
   *
   * @return
   */
  protected Tracer getTracer() {
    return tracer;
  }

  @Deprecated
  public AgentSpan afterStart(final AgentSpan span) {
    afterStart(span.getSpan());
    return span;
  }

  @Deprecated // Create spans with beginSpan and this method is no longer needed
  public Span afterStart(final Span span) {
    assert span != null;
    final String spanType = getSpanType();
    if (spanType != null) {
      span.setAttribute(MoreTags.SPAN_TYPE, spanType);
    }
    final String component = getComponentName();
    if (component != null) {
      span.setAttribute(Tags.COMPONENT, component);
    }
    return span;
  }

  @Deprecated
  public AgentScope beforeFinish(final AgentScope scope) {
    assert scope != null;
    beforeFinish(scope.span());
    return scope;
  }

  @Deprecated
  public AgentSpan beforeFinish(final AgentSpan span) {
    beforeFinish(span.getSpan());
    return span;
  }

  @Deprecated // Does nothing, so no longer needed
  public Span beforeFinish(final Span span) {
    assert span != null;
    return span;
  }

  @Deprecated
  public AgentScope onError(final AgentScope scope, final Throwable throwable) {
    assert scope != null;
    onError(scope.span(), throwable);
    return scope;
  }

  @Deprecated
  public AgentSpan onError(final AgentSpan span, final Throwable throwable) {
    onError(span.getSpan(), throwable);
    return span;
  }

  /**
   * Called by instrumenters when an error is detected. Adds excpetion details to the supplied span.
   *
   * @param span
   * @param throwable
   * @return
   */
  public Span onError(final Span span, final Throwable throwable) {
    assert span != null;
    if (throwable != null) {
      span.setStatus(Status.UNKNOWN);
      addThrowable(
          span, throwable instanceof ExecutionException ? throwable.getCause() : throwable);
    }
    return span;
  }

  @Deprecated
  public AgentSpan onPeerConnection(
      final AgentSpan span, final InetSocketAddress remoteConnection) {
    onPeerConnection(span.getSpan(), remoteConnection);
    return span;
  }

  /**
   * Called from instrumenters when a server accepts a connection from a client. Decorates the
   * current span with information about the cnnection, such as peer address and port.
   *
   * @param span The current {@link Span}
   * @param remoteConnection
   * @return
   */
  public Span onPeerConnection(final Span span, final InetSocketAddress remoteConnection) {
    assert span != null;
    if (remoteConnection != null) {
      onPeerConnection(span, remoteConnection.getAddress());

      span.setAttribute(Tags.PEER_HOSTNAME, remoteConnection.getHostName());
      span.setAttribute(Tags.PEER_PORT, remoteConnection.getPort());
    }
    return span;
  }

  @Deprecated
  public AgentSpan onPeerConnection(final AgentSpan span, final InetAddress remoteAddress) {
    onPeerConnection(span.getSpan(), remoteAddress);
    return span;
  }

  /**
   * Called from instrumenters when a server accepts a connection from a client. Decorates the
   * current span with information about the cnnection, such as peer address and port.
   *
   * @param span The current {@link Span}
   * @param remoteAddress
   * @return
   */
  public Span onPeerConnection(final Span span, final InetAddress remoteAddress) {
    assert span != null;
    if (remoteAddress != null) {
      span.setAttribute(Tags.PEER_HOSTNAME, remoteAddress.getHostName());
      if (remoteAddress instanceof Inet4Address) {
        span.setAttribute(Tags.PEER_HOST_IPV4, remoteAddress.getHostAddress());
      } else if (remoteAddress instanceof Inet6Address) {
        span.setAttribute(Tags.PEER_HOST_IPV6, remoteAddress.getHostAddress());
      }
    }
    return span;
  }

  /**
   * Called from instrumenters when an uncaught exception is detected upon method exit. Attaches the
   * exception details, including stack trace, to the supplied {@link Span}
   *
   * @param span
   * @param throwable
   */
  public static void addThrowable(final Span span, final Throwable throwable) {
    final String message = throwable.getMessage();
    if (message != null) {
      span.setAttribute(MoreTags.ERROR_MSG, message);
    }
    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());

    final StringWriter errorString = new StringWriter();
    throwable.printStackTrace(new PrintWriter(errorString));
    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());
  }

  /**
   * This method is used to generate an acceptable span (operation) name based on a given method
   * reference. Anonymous classes are named based on their parent.
   *
   * @param method
   * @return
   */
  public String spanNameForMethod(final Method method) {
    return spanNameForClass(method.getDeclaringClass()) + "." + method.getName();
  }

  /**
   * This method is used to generate an acceptable span (operation) name based on a given class
   * reference. Anonymous classes are named based on their parent.
   *
   * @param clazz
   * @return
   */
  public String spanNameForClass(final Class clazz) {
    if (!clazz.isAnonymousClass()) {
      return clazz.getSimpleName();
    }
    String className = clazz.getName();
    if (clazz.getPackage() != null) {
      final String pkgName = clazz.getPackage().getName();
      if (!pkgName.isEmpty()) {
        className = clazz.getName().replace(pkgName, "").substring(1);
      }
    }
    return className;
  }

  /**
   * Returns a span builder congifured for creating spans compatible with this {@link BaseDecorator}
   *
   * @param name
   * @return
   */
  public Span.Builder getSpanBuilder(final String name) {
    return getTracer().spanBuilder(name);
  }

  /**
   * Begins a new span compatible with this {@link BaseDecorator}
   *
   * @param name
   * @return
   */
  public Span beginSpan(final String name) {
    final Span span = getSpanBuilder(name).startSpan();
    final String spanType = getSpanType();
    if (spanType != null) {
      span.setAttribute(MoreTags.SPAN_TYPE, spanType);
    }
    final String component = getComponentName();
    if (component != null) {
      span.setAttribute(Tags.COMPONENT, component);
    }
    return span;
  }

  /**
   * Creates a Scope based on a {@link Span}.
   *
   * @param span The {@link Span}
   * @return
   */
  public Scope createScope(final Span span) {
    return getTracer().withSpan(span);
  }

  /**
   * Creates a {@link SpanScopePair} based on a span and a generated Scope for the supplied Span
   *
   * @param span
   * @return
   */
  public SpanScopePair createSpanScopePair(final Span span) {
    return new SpanScopePair(span, getTracer().withSpan(span));
  }

  /**
   * Returns a {@link HttpTextFormat} compatible with this Decorator
   *
   * @return
   */
  public HttpTextFormat<SpanContext> getHttpTextFormat() {
    return getTracer().getHttpTextFormat();
  }

  /**
   * Injects attributes from a {@link SpanContext} into an object as specified by the setter
   *
   * @param context The {@link SpanContext} to read
   * @param destination The object to inject the atttibutes into
   * @param setter The setter to use
   * @param <T> The type of object to inject attributes into
   */
  public <T> void inject(
      final SpanContext context, final T destination, final HttpTextFormat.Setter<T> setter) {
    getHttpTextFormat().inject(context, destination, setter);
  }

  /**
   * Injects attributes from a {@link Span} into an object as specified by the setter
   *
   * @param span The {@link Span} to read
   * @param destination The object to inject the atttibutes into
   * @param setter The setter to use
   * @param <T> The type of object to inject attributes into
   */
  public <T> void inject(
      final Span span, final T destination, final HttpTextFormat.Setter<T> setter) {
    getHttpTextFormat().inject(span.getContext(), destination, setter);
  }

  /**
   * Extracts attributes from an object and creates a new {@link SpanContext} based on those values
   *
   * @param source The source object
   * @param getter The Getter used to extract the values
   * @param <T> The type of the object holding values
   * @return
   */
  public <T> SpanContext extract(final T source, final HttpTextFormat.Getter<T> getter) {
    return getHttpTextFormat().extract(source, getter);
  }

  /**
   * Returns the current {@link Span}. Will never return null. If no current span is present, this
   * method will return a dummy span. To check whether the span is valid, use
   * span.getContext().isValid() or the isCurrentSpanValid method.
   *
   * @return
   */
  public Span getCurrentSpan() {
    return getTracer().getCurrentSpan();
  }

  /**
   * Returns true if there is a current @{link Span} that has been properly initialized and is not a
   * dummy Span.
   *
   * @return
   */
  public boolean isCurrentSpanValid() {
    return getTracer().getCurrentSpan().getContext().isValid();
  }
}
